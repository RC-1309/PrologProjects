# PrologProjects

Оригинал заданий доступен по [ссылке](https://www.kgeorgiy.info/courses/paradigms/homeworks.html#prolog-primes).

## Поиск простых чисел
- Перед началом работы необходимо запустить ```init(N)```, где вместо N нужно подставить максимальное значение, которое будет в запросах
- Доступны правила:
  - ```prime(N)```, проверяющее, что N – простое число.
  - ```composite(N)```, проверяющее, что N – составное число.
  - ```prime_divisors(N, Divisors)```, проверяющее, что список Divisors содержит все простые делители числа N, упорядоченные по возрастанию. Если N делится на простое число P несколько раз, то Divisors содержит соответствующее число копий P.
  - ```compact_prime_divisors(N, CDs)```, где CDs — список пар (простое, степень): ```compact_prime_divisors(120, [(2, 3), (3, 1), (5, 1)])```.
  - ```divisors_divisors(N, Divisors)```, где Divisors — список разложений на простые делители делителей числа N: ```divisors_divisors(12, [[], [2], [3], [2,2], [2,3], [2,2,3]])```.

## Авл-дерево
Полностью функциональное дерево поиска с логарифмичной высотой.
- Доступны операции:
  - ```map_put(TreeMap, Key, Value, Result)``` добавляющее пару ключ-значение в массив, или заменяющее текущее значение для ключа (O(log n));
  - ```map_remove(TreeMap, Key, Result)``` удаляющее отображение для ключа (O(log n));
  - ```map_get(TreeMap, Key, Value)```, проверяющее, что массив содержит заданную пару ключ-значение (O(log n));
  - ```map_build(ListMap, TreeMap)```, строящее дерево из неупорядоченного списка пар ключ-значение (O(n log n));
  - ```map_getCeiling(Map, Key, Value)```, возвращающее значение, соответствующее минимальному ключу, большему либо равному заданному;
  - ```map_putCeiling(Map, Key, Value, Result)```, заменяющее значение, соответствующее минимальному ключу, большему либо равному заданному (если такой существует).

## Разбор выражений

- Доступные правила:
  - `evaluate(Expression, Variables, Result)`, вычисляющее арифметические выражения.
    - Пример вычисления выражения ```2(-x)-3``` для ```x = 5```:
      ```
      evaluate(
          operation(op_subtract,
              operation(op_multiply,
                  const(2),
                  operation(op_negate, variable(x))
              ),
              const(3)
          ),
          [(x, 5)],
          -13
      )
      ```
    - Поддерживаемые операции:
      - Сложение ```(op_add, +)```;
      - Вычитание ```(op_subtract, -)```;
      - Умножение ```(op_multiply, *)```;
      - Деление ```(op_divide, /)```;
      - Противоположное число ```(op_negate, negate)```;
      - Пусть, если переданное число больше 0, то это true, иначе false, результат: `true -> 1`, `false -> 0`;
      - `op_not` (`!`) - отрицание: `!5` равно `0`;
      - `op_and` (`&&`) – и: `5 & -6` равно `0`;
      - `op_or` (`||`) - или: `5 & -6` равно `1`;
      - `op_xor` (`^^`) - исключающее или: `5 ^ -6` равно `1`;
      - `op_impl` (`->`) – импликация (правоассоциативна): `-4 -> 1` равно 1;
      - `op_iff`  (`<->`) - тогда и только тогда: `2 <-> 6` равно 1.
    - Поддерживаются переменные, состоящих из произвольного количества букв XYZ в любом регистре, тогда настоящее имя переменной определяется первой буквой ее имени.
  - `infix_str(Expression, Atom)`, разбирающее/выводящее выражения, записанные в полноскобочной инфиксной форме. Например,
    ```
    infix_str(
        operation(op_subtract,
            operation(op_multiply,
                const(2),
                operation(op_negate, variable(x))),
            const(3)
        ),
        '((2 * negate x) - 3)'
    ```
- Правила реализованы с применением DC-грамматик.
